<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My New Hugo Site</title>
    <link>/</link>
    <description>Recent content on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Alex Tardif: An Opinionated Post on Modern Rendering Abstraction Layers</title>
      <link>/notes/20201215225804-alex_tardif_graphics_engineer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/notes/20201215225804-alex_tardif_graphics_engineer/</guid>
      <description>link http://www.alextardif.com/RenderingAbstractionLayers.html tags graphics programming  Alex explains what a &amp;ldquo;good&amp;rdquo; renderer abstraction should have and not have.</description>
    </item>
    
    <item>
      <title>Alex Tardif: Area Lights</title>
      <link>/notes/20201215224250-alex_tardif_graphics_engineer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/notes/20201215224250-alex_tardif_graphics_engineer/</guid>
      <description>link http://www.alextardif.com/arealights.html tags graphics programming, area lights, lighting  All lighting computations are done in view-space (not world-space!) This implementation is based on a deferred renderer,it renders geometry in the shape of the lights and uses a stencil pass to compute lighting only on pixels affected by lights.
Sphere Area Lights float3 r = reflect(-viewDir, normal); float3 L = input.lightPositionView.xyz - positionView; float3 centerToRay = (dot(L, r) * r) - L; float3 closestPoint = L + centerToRay * saturate(sphereRadius / length(centerToRay)); L = normalize(closestPoint); float distLight = length(closestPoint); .</description>
    </item>
    
    <item>
      <title>area lights</title>
      <link>/notes/20201215224331-area_lights/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/notes/20201215224331-area_lights/</guid>
      <description></description>
    </item>
    
    <item>
      <title>C&#43;&#43;: std::optional</title>
      <link>/notes/20201219115141-c_std_optional/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/notes/20201219115141-c_std_optional/</guid>
      <description>tags cpp  Basically a ripoff of Rust&amp;rsquo;s std::option.
One thing to keep in mind when using std::optional is that it doesn&amp;rsquo;t have the same semantics as pointers, this code is perfectly fine:
auto garbage = std::nullopt; auto even_more_garbage = *garbage; It doesn&amp;rsquo;t throw any exception and will silently fails. The equivalent to Rust&amp;rsquo;s unwrap() is value().
auto garbage = std::nullopt; auto not_garbage = garbage.value(); // &amp;lt;-- Will throw a std::bad_optional_access exception!</description>
    </item>
    
    <item>
      <title>cpp</title>
      <link>/notes/20201218231726-cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/notes/20201218231726-cpp/</guid>
      <description></description>
    </item>
    
    <item>
      <title>graphics programming</title>
      <link>/notes/20201215183931-graphics_programming/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/notes/20201215183931-graphics_programming/</guid>
      <description></description>
    </item>
    
    <item>
      <title>lighting</title>
      <link>/notes/20201215224339-lighting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/notes/20201215224339-lighting/</guid>
      <description></description>
    </item>
    
    <item>
      <title>linear algebra</title>
      <link>/notes/20201216235026-linear_algebra/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/notes/20201216235026-linear_algebra/</guid>
      <description></description>
    </item>
    
    <item>
      <title>maths</title>
      <link>/notes/20201216235016-maths/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/notes/20201216235016-maths/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Modern C for C&#43;&#43; Peeps</title>
      <link>/notes/20201218231643-modern_c_for_c_peeps/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/notes/20201218231643-modern_c_for_c_peeps/</guid>
      <description>link https://floooh.github.io/2019/09/27/modern-c-for-cpp-peeps.html tags cpp  What you see in a lot of C code:
typedef struct { int a, b, c; } bla_t; bla_t bla = ...; But when you want to forwards declare such struct:
// forward-declaring bla_t and a function using bla_t: struct bla_t; void func(struct bla_t bla); // actual struct and function, using the typedef: typedef struct { int a, b, c; } bla_t; void func(bla_t bla) { // &amp;lt;= warning &amp;#39;parameter different from declaration&amp;#39;  .</description>
    </item>
    
    <item>
      <title>Sample Distribution Shadow Maps</title>
      <link>/notes/sample_distribution_shadow_maps/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/notes/sample_distribution_shadow_maps/</guid>
      <description>link http://advances.realtimerendering.com/s2010/Lauritzen-SDSM(SIGGRAPH%202010%20Advanced%20RealTime%20Rendering%20Course).pdf tags graphics programming, shadow mapping  Algorithm Basically PSSM but instead of partitioning the entire frustum, tight bounds are used.
Two partitioning variants:
 K-means clustering: place partitions where there are a lot of samples, good results for average error Adaptive logarithmic: avoids gaps in Z  But these two approaches require a depth histogram and are very situational. A simpler min/max reduction with a basic logarithmic scheme is recommended.</description>
    </item>
    
    <item>
      <title>shadow mapping</title>
      <link>/notes/20201215183947-shadow_mapping/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/notes/20201215183947-shadow_mapping/</guid>
      <description></description>
    </item>
    
    <item>
      <title>The projection matrix in vulkan</title>
      <link>/notes/20201216234910-the_projection_matrix_in_vulkan/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/notes/20201216234910-the_projection_matrix_in_vulkan/</guid>
      <description>tags graphics programming, vulkan, linear algebra  Explain the different coordinates systems: local -&amp;gt; world -&amp;gt; camera/eye -&amp;gt; clip -&amp;gt; ndc -&amp;gt; fragment.I will demonstrate the formulas for a specific set of settings: Vulkan (RH clip space with Y towards the bottom, same for viewport fragment space), RH world coordinates with Y-up. Don&amp;rsquo;t worry you can still follow and adapt the formulas with your settings.
The projection matrix will transform our coordinates from eye space to clip space.</description>
    </item>
    
    <item>
      <title>vulkan</title>
      <link>/notes/20201216234943-vulkan/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/notes/20201216234943-vulkan/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
