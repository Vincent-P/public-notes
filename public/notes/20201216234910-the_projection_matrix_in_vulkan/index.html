<!DOCTYPE html>
<html lang="en-us">
<title>The projection matrix in vulkan | My New Hugo Site</title>
<meta charset="utf-8">
<meta name="generator" content="Hugo 0.79.1" />
<meta name="description" content="my blog">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="css/index.css">
<link rel="canonical" href="/notes/20201216234910-the_projection_matrix_in_vulkan/">
<link rel="alternate" type="application/rss+xml" href="" title="My New Hugo Site">

<header>
  
    <a href="">My New Hugo Site</a>
  
  
    <nav>
    
      <a href="/about/">About</a>
    
    </nav>
  
</header>

<article>
  <header>
    <h1>The projection matrix in vulkan</h1>
    
  </header>
  <dl>
<dt>tags</dt>
<dd><a href="/notes/20201215183931-graphics_programming/">graphics programming</a>, <a href="/notes/20201216234943-vulkan/">vulkan</a>, <a href="/notes/20201216235026-linear_algebra/">linear algebra</a></dd>
</dl>
<p><!-- raw HTML omitted -->Explain the different coordinates systems: local -&gt; world -&gt; camera/eye -&gt; clip -&gt; ndc -&gt; fragment.<!-- raw HTML omitted --></p>
<p>I will demonstrate the formulas for a specific set of settings: Vulkan (RH clip space with Y towards the bottom, same for viewport fragment space), RH world coordinates with Y-up.
Don&rsquo;t worry you can still follow and adapt the formulas with <strong>your</strong> settings.</p>
<p>The projection matrix will transform our coordinates from eye space to clip space. The clip space is a homogenous space and only after the fixed-function &ldquo;divide by w&rdquo; the coordinates will become normalized.
So we will need to figure out a good w value to divide everything.
Let&rsquo;s start with finding out the x and y values, the depth will come after.</p>
<p>The first step to find x, y and w is to project a given point in world space in the near plane of the frustum.</p>
<p>The frustum is a big pyramid with the camera as apex. It is relatively easy to project the x and y coordinates in the near plane using the Intercept theorem.
Let \(x_p\), \(y_p\) and \(z_p\) be the coordinates of the projected point in the near plane and \(x_e\), \(y_e\), \(z_e\) be the coordinates of the points in eye space, the ratio between a projected coordinate and the coordinate in eye space is the same.
So \(\frac{x_p}{x_e} = \frac{y_p}{y_e} = \frac{z_p}{z_e}\). We already know that \(z_p\) is n because the projected point is on the near plane.
In the end we have:</p>
<p>\begin{align*}
&amp; x_p = \frac{1}{-z_e} n x_e\\\<br>
&amp; y_p = \frac{1}{-z_e} n y_e\\\<br>
&amp; z_p = \frac{1}{-z_e} n z_e = n
\end{align*}</p>
<p>One interesting thing is that both \(x_p\) and \(y_p\) are inverse proportional to \(-z_e\). Let&rsquo;s use this as w for the fixed-function divide.</p>
<p>w_c = -1 * z_e
// matrix with last row</p>
<p>We have one line of our matrix! We still have to find x_c and y_c though&hellip;</p>
<p>Now that we have expressed x_p and y_p in terms of x_e and y_e, let&rsquo;s try to express x_n and y_n (n stands for Normalized device coordinates).
The near plane of our frustum is defined by 4 corners (l, t), (r, t), (r, b) and (l, b). We want to match these with (-1, -1), (1, -1), (1, 1) and (-1, 1) respectively.
<strong>Note</strong>: If you have a different clip space you will need to adjust the corners of the near clip plane! Here the Y axis is down because that&rsquo;s how it is in Vulkan.</p>
<p>The mapping from the near frustum plane and the near clip plane is a linear function of the form f(x) = ax + b.
Starting with the x coordinate, we already know 2 points: f(l) = -1 and f(r) = 1.
We can use the formula to find the slope of the function and then by replacing the known values in the function we can find the constant term.</p>
<p>// maths for x_n = f(x_p)</p>
<p>The same for y, the 2 known points are f(t) = -1 and f(b) = 1.</p>
<p>// maths for y_n = f(y_p)</p>
<p>Now we just have to replace x_p and y_p by the expressions we found earlier in terms of x_e and y_e.
You might be wondering why we are expressing x_n and y_n and not x_c and y_c.
The normalized device coordinates are just the clip coordinates but divided by w_c, we are using -z_e for this, so if we find x_n and y_n, we just have to multiply by -z_e to find the clip coordinates!</p>
<p>// maths for x_n = f(x_e)</p>
<p>Similarly for y,</p>
<p>// maths for y_n = f(y_e)</p>
<p>We can simply read the coefficients from the last lines to fill the first two lines of the matrix, only one row is missing now!</p>
<p>// matrix with all rows except z</p>
<p>Unfortunately we can&rsquo;t use the same method to find the coefficients for z, because the z will always be the near plane when projecting a point to the near plane.
We know that the z coordinate does not depend on x and y, so let&rsquo;s fill the remaining row with 0 for x and y, and A and B for the coefficients we need to find.</p>
<p>// matrix with all rows but A and B as coefficients</p>
<p>By definition z_n is :
z_n = z_c / w_c = A * z_e + B * w_e / - z_e</p>
<p>w_e is always going to be 1 because it&rsquo;s a point. // TODO explain :D</p>
<p>z_n = z_c / w_c = A * z_e + B / - z_e</p>
<p>Once again we know that when z_e is on the near plane z_n should be 1 and when on the far plane z_n should be 0.
<strong>Note</strong>: Using 1 for near and 0 for far is called &ldquo;Reverse Depth&rdquo;, basically it&rsquo;s just better than using -1/1 or 0/1 so just use it.</p>
<p>// maths for finding out A and B</p>
<p>Here is our final expression for z_n:</p>
<p>// z_n =</p>
<p>Our matrix is completely filled now yay!</p>
<p>Wait how do I use it now in my renderer code? You might be asking.
Usually a frustum is symmetric, that is l = -r and b = -t, that eliminates 2 coefficients in the matrix.
It&rsquo;s also easier to reason about field of view rather than frustum corners depending on the near plane value, so let&rsquo;s replace the corners with the field of view and aspect ratio.</p>
<p>// new coefficients for x and y using fov and aspect ratio</p>
<p>Bonus: here is my c++ code for the perspective matrix:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">float4x4 <span style="color:#a6e22e">perspective</span>(<span style="color:#66d9ef">float</span> fov, <span style="color:#66d9ef">float</span> aspect_ratio, <span style="color:#66d9ef">float</span> n, <span style="color:#66d9ef">float</span> f, float4x4 <span style="color:#f92672">*</span>inverse)
{
    <span style="color:#66d9ef">float</span> tan <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>tan(to_radians(fov) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2.0f</span>);
    <span style="color:#66d9ef">float</span> x  <span style="color:#f92672">=</span> <span style="color:#ae81ff">2.0f</span> <span style="color:#f92672">/</span> (tan <span style="color:#f92672">*</span> aspect_ratio);
    <span style="color:#66d9ef">float</span> y  <span style="color:#f92672">=</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">2.0</span> <span style="color:#f92672">/</span> tan;
    <span style="color:#66d9ef">float</span> f_on_n_minus_f <span style="color:#f92672">=</span> <span style="color:#f92672">-</span> f <span style="color:#f92672">/</span> (n <span style="color:#f92672">-</span> f);

    <span style="color:#66d9ef">float</span> A <span style="color:#f92672">=</span> f_on_n_minus_f;
    <span style="color:#66d9ef">float</span> B <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>n <span style="color:#f92672">*</span> f_on_n_minus_f;

    <span style="color:#75715e">// clang-format off
</span><span style="color:#75715e"></span>    float4x4 projection{{
	x,    <span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">0.0f</span>,  <span style="color:#ae81ff">0.0f</span>,
	<span style="color:#ae81ff">0.0f</span>, y,    <span style="color:#ae81ff">0.0f</span>,  <span style="color:#ae81ff">0.0f</span>,
	<span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">0.0f</span>,    A,    B,
	<span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">0.0f</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">0.0f</span>,
    }};
    <span style="color:#75715e">// clang-format on
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">if</span> (inverse)
    {
	<span style="color:#75715e">// clang-format off
</span><span style="color:#75715e"></span>	<span style="color:#f92672">*</span>inverse <span style="color:#f92672">=</span> float4x4({
	    <span style="color:#ae81ff">1</span><span style="color:#f92672">/</span>x,  <span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">0.0f</span>,
	    <span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">1</span><span style="color:#f92672">/</span>y,  <span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">0.0f</span>,
	    <span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">0.0f</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1.0f</span>,
	    <span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">0.0f</span>,  <span style="color:#ae81ff">1</span><span style="color:#f92672">/</span>B,  A<span style="color:#f92672">/</span>B,
	});
	<span style="color:#75715e">// clang-format on
</span><span style="color:#75715e"></span>    }

    <span style="color:#66d9ef">return</span> projection;
}
</code></pre></div>
</article>



</html>
